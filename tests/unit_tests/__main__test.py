"""Tests for :mod:`siptools_research.__main__` module."""
import sys

from unittest import mock

import pytest

from metax_access.metax import (
    DS_STATE_TECHNICAL_METADATA_GENERATED,
    DS_STATE_TECHNICAL_METADATA_GENERATION_FAILED,
    DS_STATE_METADATA_CONFIRMED,
    DS_STATE_INVALID_METADATA,
    DS_STATE_METADATA_VALIDATION_FAILED,
    DS_STATE_ACCEPTED_TO_DIGITAL_PRESERVATION
)

import siptools_research.__main__
from siptools_research.dataset import Dataset
from siptools_research.exceptions import (InvalidDatasetFileError,
                                          InvalidDatasetError)
from tests.conftest import UNIT_TEST_CONFIG_FILE


@pytest.mark.parametrize('set_preservation_state', [True, False])
def test_main_generate(mocker, set_preservation_state, requests_mock):
    """Test that correct function is called from main function when "generate"
    command is used.

    :param mocker: Pytest-mock mocker
    :param bool set_preservation_state: Use --set-preservation-state
                                        flag
    :param requests_mock: HTTP request mocker
    :returns: ``None``
    """
    mock_generate \
        = mocker.patch('siptools_research.__main__.generate_metadata')
    mock_validate \
        = mocker.patch('siptools_research.__main__.validate_metadata')
    mock_preserve = mocker.patch('siptools_research.__main__.preserve_dataset')

    # Mock Metax
    requests_mock.patch('/rest/v2/datasets/1')

    # Run main function with "generate" as command
    args = [
        'siptools-research',
        '--config',
        UNIT_TEST_CONFIG_FILE,
        'generate',
        '1'
    ]
    if set_preservation_state:
        args.append('--set-preservation-state')

    with mock.patch.object(sys, 'argv', args):
        siptools_research.__main__.main()

    # The generate_metadata function should be called.
    mock_generate.assert_called_with('1', UNIT_TEST_CONFIG_FILE)
    mock_validate.assert_not_called()
    mock_preserve.assert_not_called()

    if set_preservation_state:
        assert requests_mock.last_request.json() \
            == {'preservation_state': DS_STATE_TECHNICAL_METADATA_GENERATED,
                'preservation_description': 'Technical metadata '
                                            'generated by system admin'}
    else:
        assert not requests_mock.called


def test_metadata_generation_error(mocker, requests_mock):
    """Test that preservation state is set if metadata generation fails.

    :param mocker: Pytest-mock mocker
    :param requests_mock: HTTP request mocker
    :returns: ``None``
    """
    mocker.patch(
        'siptools_research.__main__.generate_metadata',
        side_effect=InvalidDatasetFileError("Invalid file", ['foobar'])
    )
    # Mock Metax
    requests_mock.get('/rest/v2/datasets/1', json={})
    requests_mock.patch('/rest/v2/datasets/1')

    # Run main function with "generate" as command
    args = [
        'siptools-research',
        '--config',
        UNIT_TEST_CONFIG_FILE,
        'generate',
        '1',
        '--set-preservation-state'
    ]
    with pytest.raises(InvalidDatasetFileError):
        with mock.patch.object(sys, 'argv', args):
            siptools_research.__main__.main()

    assert requests_mock.last_request.json() \
        == {'preservation_state':
            DS_STATE_TECHNICAL_METADATA_GENERATION_FAILED,
            'preservation_description': "Invalid file: ['foobar']"}


@pytest.mark.parametrize('dummy_doi', [True, False])
@pytest.mark.parametrize('set_preservation_state', [True, False])
def test_main_validate(mocker,
                       set_preservation_state,
                       dummy_doi,
                       requests_mock):
    """Test that correct function is called from main function when "validate"
    command is used.

    :param mocker: Pytest-mock mocker
    :param bool set_preservation_state: Use --set-preservation-state
                                        flag
    :param bool dummy_doi: Use --dummy-doi flag
    :param requests_mock: HTTP request mocker
    :returns: ``None``
    """
    mock_preserve = mocker.patch('siptools_research.__main__.preserve_dataset')
    mock_validate \
        = mocker.patch('siptools_research.__main__.validate_metadata')
    mock_generate \
        = mocker.patch('siptools_research.__main__.generate_metadata')

    # Mock Metax
    requests_mock.patch('/rest/v2/datasets/2')

    # Run main function with "validate" as command
    args = [
        'siptools-research',
        '--config',
        UNIT_TEST_CONFIG_FILE,
        'validate',
        '2'
    ]
    if set_preservation_state:
        args.append('--set-preservation-state')

    if dummy_doi:
        args.append('--dummy-doi')

    with mock.patch.object(sys, 'argv', args):
        siptools_research.__main__.main()

    # The validate_metadata function should be called.
    dummy_doi_value = "true" if dummy_doi else "false"
    mock_validate.assert_called_with(
        '2', UNIT_TEST_CONFIG_FILE, dummy_doi=dummy_doi_value
    )

    mock_generate.assert_not_called()
    mock_preserve.assert_not_called()

    if set_preservation_state:
        assert requests_mock.last_request.json() \
            == {'preservation_state': DS_STATE_METADATA_CONFIRMED,
                'preservation_description': 'Metadata is valid'}
    else:
        assert not requests_mock.called


@pytest.mark.parametrize(
    'exception,expected_state,expected_description',
    [
        (Exception('Something unexpected happened'),
         DS_STATE_METADATA_VALIDATION_FAILED,
         'Validation failed for unknown reason'),
        (InvalidDatasetError('Missing metadata'),
         DS_STATE_INVALID_METADATA,
         'Metadata is invalid: Missing metadata'),
    ]
)
def test_validation_failure(
    mocker,
    exception,
    expected_state,
    expected_description,
    requests_mock
):
    """Test that preservation state is set if validation fails.

    :param mocker: Pytest-mock mocker
    :param exception: Exception that will cause the failure
    :param expected_state: Expected preservation state after failure
    :param expected_description: Description for preservation state
    :param requests_mock: HTTP request mocker
    :returns: ``None``
    """
    mocker.patch('siptools_research.__main__.validate_metadata',
                 side_effect=exception)

    # Mock Metax
    requests_mock.get('/rest/v2/datasets/2', json={})
    requests_mock.patch('/rest/v2/datasets/2')

    # Run main function with "validate" as command
    args = [
        'siptools-research',
        '--config',
        UNIT_TEST_CONFIG_FILE,
        'validate',
        '2',
        '--set-preservation-state'
    ]
    with pytest.raises(type(exception)):
        with mock.patch.object(sys, 'argv', args):
            siptools_research.__main__.main()

    assert requests_mock.last_request.json() \
        == {'preservation_state': expected_state,
            'preservation_description': expected_description}


def test_main_preserve(mocker, requests_mock):
    """Test that correct function is called from main function when "preserve"
    command is used.

    :param mocker: Pytest-mock mocker
    :parma requests_mock: HTTP request mocker
    :returns: ``None``
    """
    # Mock Metax
    requests_mock.patch("/rest/v2/datasets/3")

    mock_preserve = mocker.patch('siptools_research.__main__.preserve_dataset')
    mock_validate \
        = mocker.patch('siptools_research.__main__.validate_metadata')
    mock_generate \
        = mocker.patch('siptools_research.__main__.generate_metadata')

    # Run main function with "preserve" as command
    args = ['siptools-research',
            '--config', UNIT_TEST_CONFIG_FILE,
            'preserve', '3']
    with mock.patch.object(sys, 'argv', args):
        siptools_research.__main__.main()

    # The preserve_dataset function should be called.
    mock_preserve.assert_called_with('3', UNIT_TEST_CONFIG_FILE)
    mock_generate.assert_not_called()
    mock_validate.assert_not_called()

    # Check that preservation state of dataset was changed
    json_message = requests_mock.last_request.json()
    assert json_message['preservation_state'] \
        == DS_STATE_ACCEPTED_TO_DIGITAL_PRESERVATION
    assert json_message['preservation_description'] == 'In packaging service'


@pytest.mark.usefixtures('testmongoclient', 'pkg_root')
def test_main_workflow_match(capsys, monkeypatch):
    """Test that workflow command returns the correct workflow.

    :returns: ``None``
    """
    # Start preservation workflow for a dataset
    Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE).preserve()

    # Search for the dataset
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "workflow", "aineisto_1"
        ]
    )
    siptools_research.__main__.main()

    out, _ = capsys.readouterr()
    assert out == ('Dataset identifier: aineisto_1\n'
                   'Target: preservation\n')


@pytest.mark.usefixtures('testmongoclient', 'pkg_root')
def test_main_workflow_no_matches(capsys, monkeypatch):
    """Test that worklow command prints the correct error message.

    :returns: ``None``
    """
    # Start preservation workflow for a dataset
    Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE).preserve()

    # Search for a dataset that does not yet have a preservation
    # workflow
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "workflow", "aineisto_2"
        ]
    )
    siptools_research.__main__.main()

    out, _ = capsys.readouterr()
    error = 'Could not find dataset with identifier: aineisto_2'
    assert error in out


@pytest.mark.usefixtures('testmongoclient', 'pkg_root')
def test_main_workflows_match(capsys, monkeypatch):
    """Test that workflows command returns the correct workflow.

    :returns: ``None``
    """
    # Add a single workflow document to the db
    Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE).preserve()

    # Run siptools-research workflows --enabled
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "workflows", "--enabled"
        ]
    )
    siptools_research.__main__.main()

    out, _ = capsys.readouterr()
    assert out == "aineisto_1\n"


@pytest.mark.usefixtures('testmongoclient', 'pkg_root')
def test_main_workflows_no_matches(capsys, monkeypatch):
    """Test that worklows command prints correct error message.

    :returns: ``None``
    """
    # Add a single workflow document to the db
    Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE).preserve()

    # Run siptools-research worklow 2
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "workflows", "--disabled"
        ]
    )
    siptools_research.__main__.main()

    out, _ = capsys.readouterr()
    error = 'Could not find any workflows'
    assert error in out


@pytest.mark.usefixtures('testmongoclient', 'pkg_root')
def test_main_status(capsys, monkeypatch):
    """Test that status command prints the correct workflow status.

    :returns: ``None``
    """
    # Add a single workflow document to the db
    Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE).preserve()

    # Run siptools-research status 1
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "status", "aineisto_1"
        ]
    )
    siptools_research.__main__.main()
    out, _ = capsys.readouterr()
    message = "Workflow is enabled\n"
    assert out == message


@pytest.mark.usefixtures('testmongoclient', 'pkg_root')
def test_main_tasks(capsys, monkeypatch):
    """Test that tasks command collects and groups all workflow tasks
    correctly.

    :returns: ``None``
    """
    # Add a single workflow document and a couple of workflow tasks to
    # the db
    dataset = Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE)
    dataset.preserve()
    dataset.log_task(
        "CreateWorkspace",
        "success",
        "Workspace directory created"
    )
    dataset.log_task(
        "ValidateMetadata",
        "success",
        "Metax metadata in valid"
    )
    dataset.log_task(
        "CreateProvenanceInformation",
        "failure",
        "Fail message"
    )

    # Run siptools-research status 1
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "tasks", "aineisto_1"
        ]
    )
    siptools_research.__main__.main()
    out, _ = capsys.readouterr()
    assert "CreateWorkspace\nValidateMetadata\n" in out
    assert "CreateProvenanceInformation" in out
    assert '"messages": "Fail message"' in out


@pytest.mark.usefixtures('testmongoclient', 'pkg_root')
def test_main_disabled(capsys, monkeypatch):
    """Test that the disable and enable commands set the correct dataset as
    disabled and enabled respectively.

    :returns: ``None``
    """
    # Add a single workflow document to the db
    Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE).preserve()

    # Disable the dataset using CLI
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "disable", "aineisto_1"
        ]
    )
    siptools_research.__main__.main()
    assert not Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE).enabled
    out, _ = capsys.readouterr()
    assert "Workflow of dataset aineisto_1 disable" in out

    # Enable the dataset using CLI
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "enable", "aineisto_1"
        ]
    )
    siptools_research.__main__.main()
    assert Dataset("aineisto_1", config=UNIT_TEST_CONFIG_FILE).enabled
    out, _ = capsys.readouterr()
    assert "Workflow of dataset aineisto_1 enabled" in out


def test_main_clean_cache(mocker, monkeypatch):
    """Test that clean_cache function is called when clean-cache subcommand is
    used.

    :param mocker: Pytest-mock mocker
    :param monkeypatch: monkeypatch object
    """
    mocked_clean_cache \
        = mocker.patch('siptools_research.__main__.clean_file_cache')

    # Run siptools-research clean-cache
    monkeypatch.setattr(
        sys, "argv", [
            "siptools-research",
            "--config", UNIT_TEST_CONFIG_FILE,
            "clean-cache"
        ]
    )
    siptools_research.__main__.main()

    # Check that clean_cache function was called with configuration file path
    # as parameter
    mocked_clean_cache.assert_called_once_with(
        'tests/data/configuration_files/siptools_research_unit_test.conf'
    )
